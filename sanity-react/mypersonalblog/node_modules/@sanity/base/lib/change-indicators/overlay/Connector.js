"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Connector = Connector;
exports.drawLine = exports.vLine = void 0;

var _react = _interopRequireDefault(require("react"));

var _constants = require("../constants");

var _svgHelpers = require("./svgHelpers");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var hLine = (top, from, to) => ({
  from: {
    top,
    left: from
  },
  to: {
    top,
    left: to
  }
});

var vLine = (left, from, to) => ({
  from: {
    top: from,
    left: left
  },
  to: {
    top: to,
    left: left
  }
});

exports.vLine = vLine;

var drawLine = line => (0, _svgHelpers.linePath)(line.from.left, line.from.top, line.to.left, line.to.top);

exports.drawLine = drawLine;

var connect = (p1, p2, dir) => {
  var midLeft = dir === 'v' ? p2.left : p1.left;
  var midTop = dir === 'v' ? p1.top : p2.top;
  return (0, _svgHelpers.quadraticBezierPath)(p1.left, p1.top, midLeft, midTop, p2.left, p2.top);
};

function Connector(props) {
  var from = props.from,
      to = props.to,
      _ = props.verticalCenter,
      clampLeft = props.clampLeft,
      clampRight = props.clampRight,
      rest = _objectWithoutProperties(props, ["from", "to", "verticalCenter", "clampLeft", "clampRight"]);

  var verticalCenter = typeof props.verticalCenter === 'number' ? props.verticalCenter : from.left + (to.left - from.left) / 2;
  var clampedFromTop = Math.min(clampLeft.bottom - _constants.CONNECTOR_CORNER_RADIUS, Math.max(from.top, clampLeft.top + _constants.CONNECTOR_CORNER_RADIUS));
  var clampedToTop = Math.min(clampRight.bottom - _constants.CONNECTOR_CORNER_RADIUS, Math.max(to.top, clampRight.top + _constants.CONNECTOR_CORNER_RADIUS)); // vertical distance between the two horizontal lines

  var vDist = clampedToTop - clampedFromTop;
  var leftArrowDir = clampedFromTop > from.top ? -1 : 1;
  var rightArrowDir = clampedToTop > to.top ? -1 : 1; // there are four arcs, so distribute their height evenly

  var arcHeight = Math.min(_constants.CONNECTOR_CORNER_RADIUS, vDist / 2);
  var shiftLeft = Math.min(Math.abs(from.top - clampedFromTop), _constants.CONNECTOR_CORNER_RADIUS / 2);
  var shiftRight = Math.min(Math.abs(to.top - clampedToTop), _constants.CONNECTOR_CORNER_RADIUS / 2);
  var hLine1 = hLine(clampedFromTop, from.left + shiftLeft, verticalCenter - _constants.CONNECTOR_CORNER_RADIUS);
  var hLine2 = hLine(clampedToTop, verticalCenter + _constants.CONNECTOR_CORNER_RADIUS, to.left - Math.min(Math.abs(to.top - clampedToTop), _constants.CONNECTOR_CORNER_RADIUS / 2));
  var vMidLine = vLine(verticalCenter, Math.max(clampedFromTop + arcHeight, clampedFromTop - _constants.CONNECTOR_CORNER_RADIUS), Math.min(clampedToTop - arcHeight, clampedToTop + _constants.CONNECTOR_CORNER_RADIUS));
  var path = connect({
    top: clampedFromTop + shiftLeft * leftArrowDir,
    left: from.left
  }, hLine1.from, 'h') + drawLine(hLine1) + connect(hLine1.to, vMidLine.from, 'v') + drawLine(vMidLine) + connect(vMidLine.to, hLine2.from, 'h') + drawLine(hLine2) + connect(hLine2.to, {
    top: clampedToTop + shiftRight * rightArrowDir,
    left: to.left
  }, 'v'); // todo: cleanup

  var sensitivePath = connect({
    top: clampedFromTop + shiftLeft * leftArrowDir,
    left: from.left - 4
  }, hLine1.from, 'h') + drawLine(hLine1) + connect(hLine1.to, vMidLine.from, 'v') + drawLine(vMidLine) + connect(vMidLine.to, hLine2.from, 'h') + drawLine(hLine2) + connect(hLine2.to, {
    top: clampedToTop + shiftRight * rightArrowDir,
    left: to.left + 4
  }, 'v');
  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement("path", _extends({
    d: path,
    fill: "none"
  }, rest)), /*#__PURE__*/_react.default.createElement("path", {
    d: sensitivePath,
    fill: "none" // use to debug "clickable area" stroke="rgba(100, 100, 0, 0.4)"
    // note: make sure to leave room for the scrollbar
    ,
    stroke: "none",
    onMouseEnter: props.onMouseEnter,
    onMouseLeave: props.onMouseLeave,
    strokeWidth: _constants.CONNECTOR_STROKE_WIDTH + 10
  }));
}